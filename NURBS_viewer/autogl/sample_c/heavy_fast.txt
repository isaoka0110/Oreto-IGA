                サンプルプログラムheavy_fastの解説

目次

1. 概要
2. プログラムの動作について
3. ソースコードの解説

このサンプルプログラムのポイント

* 「おてがる」のベンチマーク(低レベル描画APIを利用)

このサンプルプログラムで紹介されている「おてがる」API

AutoGL_GetContourColor
  コンターマップからグレード値に相当するRGBを得る。
AutoGL_SetColor2 
  色を設定する。
AutoGL_DrawLine2
  線分を描画する。
AutoGL_DrawTriangle2 
  三角形を描画する。
AutoGL_DrawColorInterpolatedTriangle2 
  各頂点ごとにRGBを指定して三角形を描画する。
AutoGL_DrawNormalInterpolatedTriangle2 
  各頂点ごとに法線方向ベクトルを指定して三角形を描画する。
AutoGL_DrawString2 
  文字列を描画する。
AutoGL_SetSelectionId2 
  セレクションIDを設定する。
AutoGL_SetTwoSideFaceFlag
  ポリゴンの両面描画を設定する。
AutoGL_BeginNativeCall
  一連のOpenGLコールの直前に挿入する。
AutoGL_EndNativeCall
  一連のOpenGLコールの直後に挿入する。



1. 概要

サンプルプログラムheavy_fastは、
「おてがる」のベンチマークプログラムの一つです。

このプログラムは、サンプルプログラムmore_sample_c/heavy.cを
ディスプレイリストを使用せずに書き直したものです。
それにより、対話性能がかなり向上し、
また描画性能もいくぶんか高速化されています。



2. プログラムの動作について

このプログラムの機能は、サンプルプログラムmore_sample_c/heavy.cと
ほとんど同じです。

ただし、ディスプレイリストUpdateModelボタンはなにもせずに
ただ単に再描画コールバックを呼び出すだけであり、
よけいな計算時間はほとんどかかりません。

一つだけ意図的にいれた機能制限ですが、
このモデルをマウスで回転させると、ある程度いくと真っ暗になります。
回しているとある角度からまた見えてくるわけですが、
これは、各YZ面のスライスを裏から見ようとすると、
見えないようにしてあるからです。



3. ソースコードの解説

サンプルプログラムのソースコードheavy_fast.cを上から順に眺めてみます。
ほとんどheavy.cと同じなので、違いだけをピックアップします。

まず、グローバル変数として、Gradeに加えてColorが用意されています。
格子データを初期化するMakeModelでは、Gradeを計算した後に、
AutoGL_GetContourColorを用いてグレード値からコンターで用いられるRGB値を
計算しておいて、それをColorに保存しています。
これにより、UpdateModelでの作業の一部をへらしています。

DrawGridでは、色の設定にはAutoGL_SetColor2を、
線分の描画にはAutoGL_DrawLine2というふうに、
いつもの「おてがる」の描画命令とは若干異なった命令が使用されています。
細かく見てみると、引数自体は同じようですが、
実はこれらはdoubleではなく、float型をとることに御注意下さい。

DrawCellについても、AutoGL_DrawTriangle2が使用されています。
さらに、新しい引数が３つ追加されています。
これは三角形の法線方向ベクトルです。
法線方向ベクトルは、この三角形が裏表どちらを向いているかも指定します。
また、長さ１に規格化されている必要があります。

DrawContourに至っては、AutoGL_DrawColorInterpolatedTriangle2が
用いられています。
AutoGL_DrawColorInterpolatedTriangle自体は
AutoGL_DrawContourTriangleと違って
グレード値のかわりにRGB値を引数とする「おてがる」の基本描画APIですが、
こんどのものはそれに加えて法線方向ベクトルが追加されています。

このように、これまでユーザーが陽に指定せず、
「おてがる」の中のどこかで計算されていたものについて、
このサンプルプログラムではそのすべてを陽に指定しています。
また、必要があればあらかじめそれを計算しておき、
メモリ上に保存しています。

なお、以下は「おてがる」の低レベル描画APIのリストです。
別名、イミディエートモード用の描画APIです。

AutoGL_SetColor2 ： 色を設定する。
AutoGL_DrawLine2 ： 線分を描画する。
AutoGL_DrawTriangle2 ： 三角形を描画する。
AutoGL_DrawColorInterpolatedTriangle2 ： 
  各頂点ごとにRGBを指定して三角形を描画する。
AutoGL_DrawNormalInterpolatedTriangle2 ： 
  各頂点ごとに法線方向ベクトルを指定して三角形を描画する。
AutoGL_DrawString2 ： 文字列を描画する。
AutoGL_SetSelectionId2 ： セレクションIDを設定する。

OpenGLでの実装では、これらはほぼ直接OpenGLのAPIをコールします。
よけいな計算はほとんど除かれています。
OpenGLのAPIは、たいていはそのままグラフィックスカードのハードウェアを
打くようになっているので、これは極めて高速です。

なお、これらは、一貫して用いられる必要があります。
あるレンダリングセッション、
これは再描画コールバックが呼ばれるごとにですが、
その中で通常の「おてがる」描画命令との混在は出来ないので御注意下さい。

サンプルプログラムのmore_sample_c/heavy.cでディスプレイリスト作成時に
かかる計算コストの大部分は、これらの計算に費やされています。
これをあらかじめプログラマが計算しておくことで、
ディスプレイリスト作成の時間は劇的に削減されるので、
つまり、ディスプレイリスト自体を使用する必要がなくなるわけです。

もう一つの高速化のポイントとして、RedrawViewにおいて、
AutoGL_SetTwoSideFaceFlagがコールされています。
これを0に設定すると、各三角形ごとに、
指定した法線方向が視線方向側に向いているものしか描画されません。
つまり、裏表が区別されます。
一方、デフォルトでは1であり、この場合には裏表両側とも表示されます。
いつもは裏表ともに描画しているので、２枚づつ描画されていることになります。
したがって、このフラグを0にすれば、描画性能が倍近く向上することもあります。

ただし、法線方向や裏表の指定に間違いがあったり、
あるいはこのサンプルプログラムのようにポリゴンを裏からのぞこうとすれば、
画面に表示されません。
各三角形ごとに法線方向ベクトルの指定は正確である必要があります。

ここまでの説明で、ディスプレイリストを使用しない場合との対比が
ご理解いただけたかと思います。

まとめると、通常３つのアプローチがあります。

A. ディスプレイリストを用いず、工夫もしない。

オブジェクトの更新、描画ともに遅いです。

B. ディスプレイリストを用いる。

オブジェクトの更新は遅いが、描画は速くなります。
つまり、一度目はオブジェクト更新により遅いが、
それを二度目以降ビューイングパラメータを変更するだけなら速くなります。
プログラムのわずかの変更で可能です。

C. ディスプレイリストを用いず、いろいろ工夫する。

オブジェクトの更新、描画ともに速くなります。
ただし、かなり工夫しなければならず、プログラムも複雑になります。
別の意味では、最大限の自由度があるとも言えます。

さて、実は、もう一つだけ方法があります。
OpenGLのコールを直接呼び出すのです。
これには、OpenGLの知識に加えて、
「おてがる」の内部構造についての知識も若干必要となるでしょう。
このときの注意ですが、OpenGLコールがでてくる前後に、
以下のような感じで２つの「おてがる」命令、
AutoGL_BeginNativeCallとAutoGL_EndNativeCallとを挿入して下さい。

AutoGL_BeginNativeCall ();

...
glBegin (GL_TRIANGLES);
glVertex3f (0.0f, 0.0f, 1.0f);
....
glEnd ();
...

AutoGL_EndNativeCall ();

これにより、高速化したい場所だけをチューニングすることや、
「おてがる」ではサポートされていない描画機能の使用が可能です。
ただし、移植性はある程度失なわれてしまうわけですが。



# 旧バージョンの「おてがる」ユーザーへ

ディスプレイリストを再実装した関係で、
OpenGLをダイレクトにコールしているプログラムに問題が生じる恐れがあります。
前記の注意を参照してください。
