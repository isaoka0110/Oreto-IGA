                サンプルプログラムheavyの解説

目次

1. 概要
2. プログラムの動作について
3. ソースコードの解説

このサンプルプログラムのポイント

* 「おてがる」のベンチマーク(ディスプレイリストを利用)

このサンプルプログラムで紹介されている「おてがる」API

AutoGL_DrawContourTriangle
  グレード値を用いてスムーズコンターを描画する。



1. 概要

サンプルプログラムheavyは、
「おてがる」のベンチマークプログラムの一つです。
このサンプルプログラムでは、２００万個の三角形を描画しています。



2. プログラムの動作について

このプログラムは、大量の三角形を単色またはスムーズコンターとして
描画するベンチマークプログラムです。

パネルには、grid、cellおよびcontourの３つのトグルがあります。
それぞれにチェックをつけると、対応するプロットが表示されます。

grid : 格子
cell : 単色でのソリッド表示
contour : スムーズコンター表示

基本的には、これらのコントロールをいじったあとで、
パネルの一番下にあるUpdateModelボタンを押すと、
ビューが更新されます。
ビューをマウスでドラッグしただけでは、
パネルでの設定変更は有効にならないので御注意下さい。

このサンプルプログラムでは、ディスプレイリストを用いています。
パネルからUpdateModelボタンを押すと、
まずディスプレイリストが作り直され、その後でそれが描画されます。
一方、ビューをマウスでドラッグすると、
マウスをリリースした時点で再描画されますが、
このときはすでに存在するディスプレイリストをそのまま描画します。

ディスプレイリストは、その最初の作成時に時間がかかるかわりに、
二度目以降の描画を高速化します。
一度目と二度目以降の速度の違いを体感してみて下さい



3. ソースコードの解説

サンプルプログラムのソースコードheavy.cを上から順に眺めてみます。

「おてがる」ヘッダファイルautogl.hのインクルードのあとに、
いくつかグローバル変数の値がでてきます。

Coordは三次元直交差分格子の各格子点における座標、
Gradeはその各格子点におけるスカラー値のグレードで、
だいたい0.0から1.0に規格化されています。
各方向１００分割なので、ほぼ１００万点のデータです。
ただし、X方向については、９９分割としています。
ここでは、YZ方向１００分割の二次元差分格子のスライスが
ちょうど１００枚存在すると考えて下さい。
YZ方向のスライスには１万枚の四辺形、つまり２万枚の三角形があり、
これが１００枚なので、合計２００万枚の三角形となります。

関数MakeModelでは、その三次元差分格子データを初期化しています。

関数DrawGridは、差分格子自体を描画します。
これは、４百万本の線分に相当します。

関数DrawCellは、X方向の１００枚のスライスを単色(紫)で描画しています。
合計２００万枚の三角形に相当します。

関数DrawContourは、X方向の１００枚のスライスを
スムーズコンター表示しています。
同じく、合計２００万枚の三角形に相当します。

AutoGL_DrawContourTriangleは「おてがる」の低レベル可視化関数の一つです。
引数としては、頂点ごとにスカラー値ではなく、
０ー１に規格化されたグレード値をとります。
これまででてきた高レベル可視化関数の中には、
実際には中でこれを呼んでいるものもあります。

#ifdefなどがいろいろありますが、現在はUSE_DISPLAY_LISTが有効です。
再描画コールバックRedrawViewでは、ディスプレイリストを描画しています。
一方、ボタンのコールバックであるUpdateModelでは、
そのディスプレイリストを作り直しています。

あと、マウスのドラッグ中再描画はオフにしてあります。

このように、ディスプレイリストはうまく用いるとレンダリングや対話性能を
ある程度高速化することができます。
ただし、ディスプレイリスト自体の編集には時間がかかります。
この例でもあるように、
描画するもののチェックを変更してUpdateModelボタンを押せば、
画面アップデートに何秒か待たされます。
そのあとで、ビューイングパラメータを変更するだけなら、かなり高速です。
最新のPCハードウェアなら、秒間２、３フレームぐらいは出そうな感じです

ディスプレイリストを使用する場合は、
それがあまり頻繁に変更されないことが前提です。
視線方向や拡大縮小率の変更をほとんど求められないような場合や、
リアルタイムアニメーションのように、
描画されるオブジェクトが毎フレームごとに更新されなければならない場合には、
ディスプレイリストは使用しないほうがよいようです。

もし、その場ごとに編集されなければならないオブジェクトがあれば、
それはディスプレイリストに入れずに、
その外で毎回編集と描画を行なうことをお薦めします。

例えば、コンターバーや座標系マーク、
あるいは時系列アニメーションでのタイムステップ表示のように、
ビューウィンドウのある特定の位置に常に表示しておきたいものは、
ワールド座標系ではその位置は視線方向の変化とともに移動してしまうため、
毎回書きなおす必要があります。

または、オブジェクトが選択されたときには、色を変化させるなどして
それをユーザーにフィードバックしなければなりません。
そういうときは、すでにあるディスプレイリストは変更せず、
その上から、選択されたオブジェクトだけを
別の色で上書きしたり、若干位置をずらして描画するといいでしょう。

ただし、もう一つのサンプルプログラムmore_sample_c/heavy_fast.cでは、
対話性能の向上ということで、この点がある程度改善されています。
ただし、そのペナルティとして、プログラム自体は若干複雑になっています。



# 旧バージョンの「おてがる」ユーザーへ

旧バージョンでは、このプログラムはたぶん動作しないでしょう。
旧バージョンの「おてがる」では、
OpenGLのディスプレイリストをそのまま用いていたので、
このぐらいの量のポリゴンだとシステムがハングする恐れがあります。

現バージョンでは、ディスプレイリストは別途「おてがる」側で
独自に再実装されているので、そのような問題はありません。
